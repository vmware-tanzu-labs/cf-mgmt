// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/vmwarepivotallabs/cf-mgmt/role"
)

type FakeManager struct {
	AssociateOrgAuditorStub        func(string, string, string, string, string) error
	associateOrgAuditorMutex       sync.RWMutex
	associateOrgAuditorArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	associateOrgAuditorReturns struct {
		result1 error
	}
	associateOrgAuditorReturnsOnCall map[int]struct {
		result1 error
	}
	AssociateOrgBillingManagerStub        func(string, string, string, string, string) error
	associateOrgBillingManagerMutex       sync.RWMutex
	associateOrgBillingManagerArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	associateOrgBillingManagerReturns struct {
		result1 error
	}
	associateOrgBillingManagerReturnsOnCall map[int]struct {
		result1 error
	}
	AssociateOrgManagerStub        func(string, string, string, string, string) error
	associateOrgManagerMutex       sync.RWMutex
	associateOrgManagerArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	associateOrgManagerReturns struct {
		result1 error
	}
	associateOrgManagerReturnsOnCall map[int]struct {
		result1 error
	}
	AssociateSpaceAuditorStub        func(string, string, string, string, string) error
	associateSpaceAuditorMutex       sync.RWMutex
	associateSpaceAuditorArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	associateSpaceAuditorReturns struct {
		result1 error
	}
	associateSpaceAuditorReturnsOnCall map[int]struct {
		result1 error
	}
	AssociateSpaceDeveloperStub        func(string, string, string, string, string) error
	associateSpaceDeveloperMutex       sync.RWMutex
	associateSpaceDeveloperArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	associateSpaceDeveloperReturns struct {
		result1 error
	}
	associateSpaceDeveloperReturnsOnCall map[int]struct {
		result1 error
	}
	AssociateSpaceManagerStub        func(string, string, string, string, string) error
	associateSpaceManagerMutex       sync.RWMutex
	associateSpaceManagerArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	associateSpaceManagerReturns struct {
		result1 error
	}
	associateSpaceManagerReturnsOnCall map[int]struct {
		result1 error
	}
	AssociateSpaceSupporterStub        func(string, string, string, string, string) error
	associateSpaceSupporterMutex       sync.RWMutex
	associateSpaceSupporterArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	associateSpaceSupporterReturns struct {
		result1 error
	}
	associateSpaceSupporterReturnsOnCall map[int]struct {
		result1 error
	}
	ClearRolesStub        func()
	clearRolesMutex       sync.RWMutex
	clearRolesArgsForCall []struct {
	}
	DeleteUserStub        func(string) error
	deleteUserMutex       sync.RWMutex
	deleteUserArgsForCall []struct {
		arg1 string
	}
	deleteUserReturns struct {
		result1 error
	}
	deleteUserReturnsOnCall map[int]struct {
		result1 error
	}
	ListOrgUsersByRoleStub        func(string) (*role.RoleUsers, *role.RoleUsers, *role.RoleUsers, *role.RoleUsers, error)
	listOrgUsersByRoleMutex       sync.RWMutex
	listOrgUsersByRoleArgsForCall []struct {
		arg1 string
	}
	listOrgUsersByRoleReturns struct {
		result1 *role.RoleUsers
		result2 *role.RoleUsers
		result3 *role.RoleUsers
		result4 *role.RoleUsers
		result5 error
	}
	listOrgUsersByRoleReturnsOnCall map[int]struct {
		result1 *role.RoleUsers
		result2 *role.RoleUsers
		result3 *role.RoleUsers
		result4 *role.RoleUsers
		result5 error
	}
	ListSpaceUsersByRoleStub        func(string) (*role.RoleUsers, *role.RoleUsers, *role.RoleUsers, *role.RoleUsers, error)
	listSpaceUsersByRoleMutex       sync.RWMutex
	listSpaceUsersByRoleArgsForCall []struct {
		arg1 string
	}
	listSpaceUsersByRoleReturns struct {
		result1 *role.RoleUsers
		result2 *role.RoleUsers
		result3 *role.RoleUsers
		result4 *role.RoleUsers
		result5 error
	}
	listSpaceUsersByRoleReturnsOnCall map[int]struct {
		result1 *role.RoleUsers
		result2 *role.RoleUsers
		result3 *role.RoleUsers
		result4 *role.RoleUsers
		result5 error
	}
	RemoveOrgAuditorStub        func(string, string, string, string) error
	removeOrgAuditorMutex       sync.RWMutex
	removeOrgAuditorArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	removeOrgAuditorReturns struct {
		result1 error
	}
	removeOrgAuditorReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveOrgBillingManagerStub        func(string, string, string, string) error
	removeOrgBillingManagerMutex       sync.RWMutex
	removeOrgBillingManagerArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	removeOrgBillingManagerReturns struct {
		result1 error
	}
	removeOrgBillingManagerReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveOrgManagerStub        func(string, string, string, string) error
	removeOrgManagerMutex       sync.RWMutex
	removeOrgManagerArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	removeOrgManagerReturns struct {
		result1 error
	}
	removeOrgManagerReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveOrgUserStub        func(string, string, string, string) error
	removeOrgUserMutex       sync.RWMutex
	removeOrgUserArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	removeOrgUserReturns struct {
		result1 error
	}
	removeOrgUserReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveSpaceAuditorStub        func(string, string, string, string) error
	removeSpaceAuditorMutex       sync.RWMutex
	removeSpaceAuditorArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	removeSpaceAuditorReturns struct {
		result1 error
	}
	removeSpaceAuditorReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveSpaceDeveloperStub        func(string, string, string, string) error
	removeSpaceDeveloperMutex       sync.RWMutex
	removeSpaceDeveloperArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	removeSpaceDeveloperReturns struct {
		result1 error
	}
	removeSpaceDeveloperReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveSpaceManagerStub        func(string, string, string, string) error
	removeSpaceManagerMutex       sync.RWMutex
	removeSpaceManagerArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	removeSpaceManagerReturns struct {
		result1 error
	}
	removeSpaceManagerReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveSpaceSupporterStub        func(string, string, string, string) error
	removeSpaceSupporterMutex       sync.RWMutex
	removeSpaceSupporterArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}
	removeSpaceSupporterReturns struct {
		result1 error
	}
	removeSpaceSupporterReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) AssociateOrgAuditor(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string) error {
	fake.associateOrgAuditorMutex.Lock()
	ret, specificReturn := fake.associateOrgAuditorReturnsOnCall[len(fake.associateOrgAuditorArgsForCall)]
	fake.associateOrgAuditorArgsForCall = append(fake.associateOrgAuditorArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AssociateOrgAuditorStub
	fakeReturns := fake.associateOrgAuditorReturns
	fake.recordInvocation("AssociateOrgAuditor", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.associateOrgAuditorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) AssociateOrgAuditorCallCount() int {
	fake.associateOrgAuditorMutex.RLock()
	defer fake.associateOrgAuditorMutex.RUnlock()
	return len(fake.associateOrgAuditorArgsForCall)
}

func (fake *FakeManager) AssociateOrgAuditorCalls(stub func(string, string, string, string, string) error) {
	fake.associateOrgAuditorMutex.Lock()
	defer fake.associateOrgAuditorMutex.Unlock()
	fake.AssociateOrgAuditorStub = stub
}

func (fake *FakeManager) AssociateOrgAuditorArgsForCall(i int) (string, string, string, string, string) {
	fake.associateOrgAuditorMutex.RLock()
	defer fake.associateOrgAuditorMutex.RUnlock()
	argsForCall := fake.associateOrgAuditorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeManager) AssociateOrgAuditorReturns(result1 error) {
	fake.associateOrgAuditorMutex.Lock()
	defer fake.associateOrgAuditorMutex.Unlock()
	fake.AssociateOrgAuditorStub = nil
	fake.associateOrgAuditorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateOrgAuditorReturnsOnCall(i int, result1 error) {
	fake.associateOrgAuditorMutex.Lock()
	defer fake.associateOrgAuditorMutex.Unlock()
	fake.AssociateOrgAuditorStub = nil
	if fake.associateOrgAuditorReturnsOnCall == nil {
		fake.associateOrgAuditorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateOrgAuditorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateOrgBillingManager(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string) error {
	fake.associateOrgBillingManagerMutex.Lock()
	ret, specificReturn := fake.associateOrgBillingManagerReturnsOnCall[len(fake.associateOrgBillingManagerArgsForCall)]
	fake.associateOrgBillingManagerArgsForCall = append(fake.associateOrgBillingManagerArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AssociateOrgBillingManagerStub
	fakeReturns := fake.associateOrgBillingManagerReturns
	fake.recordInvocation("AssociateOrgBillingManager", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.associateOrgBillingManagerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) AssociateOrgBillingManagerCallCount() int {
	fake.associateOrgBillingManagerMutex.RLock()
	defer fake.associateOrgBillingManagerMutex.RUnlock()
	return len(fake.associateOrgBillingManagerArgsForCall)
}

func (fake *FakeManager) AssociateOrgBillingManagerCalls(stub func(string, string, string, string, string) error) {
	fake.associateOrgBillingManagerMutex.Lock()
	defer fake.associateOrgBillingManagerMutex.Unlock()
	fake.AssociateOrgBillingManagerStub = stub
}

func (fake *FakeManager) AssociateOrgBillingManagerArgsForCall(i int) (string, string, string, string, string) {
	fake.associateOrgBillingManagerMutex.RLock()
	defer fake.associateOrgBillingManagerMutex.RUnlock()
	argsForCall := fake.associateOrgBillingManagerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeManager) AssociateOrgBillingManagerReturns(result1 error) {
	fake.associateOrgBillingManagerMutex.Lock()
	defer fake.associateOrgBillingManagerMutex.Unlock()
	fake.AssociateOrgBillingManagerStub = nil
	fake.associateOrgBillingManagerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateOrgBillingManagerReturnsOnCall(i int, result1 error) {
	fake.associateOrgBillingManagerMutex.Lock()
	defer fake.associateOrgBillingManagerMutex.Unlock()
	fake.AssociateOrgBillingManagerStub = nil
	if fake.associateOrgBillingManagerReturnsOnCall == nil {
		fake.associateOrgBillingManagerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateOrgBillingManagerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateOrgManager(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string) error {
	fake.associateOrgManagerMutex.Lock()
	ret, specificReturn := fake.associateOrgManagerReturnsOnCall[len(fake.associateOrgManagerArgsForCall)]
	fake.associateOrgManagerArgsForCall = append(fake.associateOrgManagerArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AssociateOrgManagerStub
	fakeReturns := fake.associateOrgManagerReturns
	fake.recordInvocation("AssociateOrgManager", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.associateOrgManagerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) AssociateOrgManagerCallCount() int {
	fake.associateOrgManagerMutex.RLock()
	defer fake.associateOrgManagerMutex.RUnlock()
	return len(fake.associateOrgManagerArgsForCall)
}

func (fake *FakeManager) AssociateOrgManagerCalls(stub func(string, string, string, string, string) error) {
	fake.associateOrgManagerMutex.Lock()
	defer fake.associateOrgManagerMutex.Unlock()
	fake.AssociateOrgManagerStub = stub
}

func (fake *FakeManager) AssociateOrgManagerArgsForCall(i int) (string, string, string, string, string) {
	fake.associateOrgManagerMutex.RLock()
	defer fake.associateOrgManagerMutex.RUnlock()
	argsForCall := fake.associateOrgManagerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeManager) AssociateOrgManagerReturns(result1 error) {
	fake.associateOrgManagerMutex.Lock()
	defer fake.associateOrgManagerMutex.Unlock()
	fake.AssociateOrgManagerStub = nil
	fake.associateOrgManagerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateOrgManagerReturnsOnCall(i int, result1 error) {
	fake.associateOrgManagerMutex.Lock()
	defer fake.associateOrgManagerMutex.Unlock()
	fake.AssociateOrgManagerStub = nil
	if fake.associateOrgManagerReturnsOnCall == nil {
		fake.associateOrgManagerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateOrgManagerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateSpaceAuditor(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string) error {
	fake.associateSpaceAuditorMutex.Lock()
	ret, specificReturn := fake.associateSpaceAuditorReturnsOnCall[len(fake.associateSpaceAuditorArgsForCall)]
	fake.associateSpaceAuditorArgsForCall = append(fake.associateSpaceAuditorArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AssociateSpaceAuditorStub
	fakeReturns := fake.associateSpaceAuditorReturns
	fake.recordInvocation("AssociateSpaceAuditor", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.associateSpaceAuditorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) AssociateSpaceAuditorCallCount() int {
	fake.associateSpaceAuditorMutex.RLock()
	defer fake.associateSpaceAuditorMutex.RUnlock()
	return len(fake.associateSpaceAuditorArgsForCall)
}

func (fake *FakeManager) AssociateSpaceAuditorCalls(stub func(string, string, string, string, string) error) {
	fake.associateSpaceAuditorMutex.Lock()
	defer fake.associateSpaceAuditorMutex.Unlock()
	fake.AssociateSpaceAuditorStub = stub
}

func (fake *FakeManager) AssociateSpaceAuditorArgsForCall(i int) (string, string, string, string, string) {
	fake.associateSpaceAuditorMutex.RLock()
	defer fake.associateSpaceAuditorMutex.RUnlock()
	argsForCall := fake.associateSpaceAuditorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeManager) AssociateSpaceAuditorReturns(result1 error) {
	fake.associateSpaceAuditorMutex.Lock()
	defer fake.associateSpaceAuditorMutex.Unlock()
	fake.AssociateSpaceAuditorStub = nil
	fake.associateSpaceAuditorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateSpaceAuditorReturnsOnCall(i int, result1 error) {
	fake.associateSpaceAuditorMutex.Lock()
	defer fake.associateSpaceAuditorMutex.Unlock()
	fake.AssociateSpaceAuditorStub = nil
	if fake.associateSpaceAuditorReturnsOnCall == nil {
		fake.associateSpaceAuditorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateSpaceAuditorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateSpaceDeveloper(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string) error {
	fake.associateSpaceDeveloperMutex.Lock()
	ret, specificReturn := fake.associateSpaceDeveloperReturnsOnCall[len(fake.associateSpaceDeveloperArgsForCall)]
	fake.associateSpaceDeveloperArgsForCall = append(fake.associateSpaceDeveloperArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AssociateSpaceDeveloperStub
	fakeReturns := fake.associateSpaceDeveloperReturns
	fake.recordInvocation("AssociateSpaceDeveloper", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.associateSpaceDeveloperMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) AssociateSpaceDeveloperCallCount() int {
	fake.associateSpaceDeveloperMutex.RLock()
	defer fake.associateSpaceDeveloperMutex.RUnlock()
	return len(fake.associateSpaceDeveloperArgsForCall)
}

func (fake *FakeManager) AssociateSpaceDeveloperCalls(stub func(string, string, string, string, string) error) {
	fake.associateSpaceDeveloperMutex.Lock()
	defer fake.associateSpaceDeveloperMutex.Unlock()
	fake.AssociateSpaceDeveloperStub = stub
}

func (fake *FakeManager) AssociateSpaceDeveloperArgsForCall(i int) (string, string, string, string, string) {
	fake.associateSpaceDeveloperMutex.RLock()
	defer fake.associateSpaceDeveloperMutex.RUnlock()
	argsForCall := fake.associateSpaceDeveloperArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeManager) AssociateSpaceDeveloperReturns(result1 error) {
	fake.associateSpaceDeveloperMutex.Lock()
	defer fake.associateSpaceDeveloperMutex.Unlock()
	fake.AssociateSpaceDeveloperStub = nil
	fake.associateSpaceDeveloperReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateSpaceDeveloperReturnsOnCall(i int, result1 error) {
	fake.associateSpaceDeveloperMutex.Lock()
	defer fake.associateSpaceDeveloperMutex.Unlock()
	fake.AssociateSpaceDeveloperStub = nil
	if fake.associateSpaceDeveloperReturnsOnCall == nil {
		fake.associateSpaceDeveloperReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateSpaceDeveloperReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateSpaceManager(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string) error {
	fake.associateSpaceManagerMutex.Lock()
	ret, specificReturn := fake.associateSpaceManagerReturnsOnCall[len(fake.associateSpaceManagerArgsForCall)]
	fake.associateSpaceManagerArgsForCall = append(fake.associateSpaceManagerArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AssociateSpaceManagerStub
	fakeReturns := fake.associateSpaceManagerReturns
	fake.recordInvocation("AssociateSpaceManager", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.associateSpaceManagerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) AssociateSpaceManagerCallCount() int {
	fake.associateSpaceManagerMutex.RLock()
	defer fake.associateSpaceManagerMutex.RUnlock()
	return len(fake.associateSpaceManagerArgsForCall)
}

func (fake *FakeManager) AssociateSpaceManagerCalls(stub func(string, string, string, string, string) error) {
	fake.associateSpaceManagerMutex.Lock()
	defer fake.associateSpaceManagerMutex.Unlock()
	fake.AssociateSpaceManagerStub = stub
}

func (fake *FakeManager) AssociateSpaceManagerArgsForCall(i int) (string, string, string, string, string) {
	fake.associateSpaceManagerMutex.RLock()
	defer fake.associateSpaceManagerMutex.RUnlock()
	argsForCall := fake.associateSpaceManagerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeManager) AssociateSpaceManagerReturns(result1 error) {
	fake.associateSpaceManagerMutex.Lock()
	defer fake.associateSpaceManagerMutex.Unlock()
	fake.AssociateSpaceManagerStub = nil
	fake.associateSpaceManagerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateSpaceManagerReturnsOnCall(i int, result1 error) {
	fake.associateSpaceManagerMutex.Lock()
	defer fake.associateSpaceManagerMutex.Unlock()
	fake.AssociateSpaceManagerStub = nil
	if fake.associateSpaceManagerReturnsOnCall == nil {
		fake.associateSpaceManagerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateSpaceManagerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateSpaceSupporter(arg1 string, arg2 string, arg3 string, arg4 string, arg5 string) error {
	fake.associateSpaceSupporterMutex.Lock()
	ret, specificReturn := fake.associateSpaceSupporterReturnsOnCall[len(fake.associateSpaceSupporterArgsForCall)]
	fake.associateSpaceSupporterArgsForCall = append(fake.associateSpaceSupporterArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.AssociateSpaceSupporterStub
	fakeReturns := fake.associateSpaceSupporterReturns
	fake.recordInvocation("AssociateSpaceSupporter", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.associateSpaceSupporterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) AssociateSpaceSupporterCallCount() int {
	fake.associateSpaceSupporterMutex.RLock()
	defer fake.associateSpaceSupporterMutex.RUnlock()
	return len(fake.associateSpaceSupporterArgsForCall)
}

func (fake *FakeManager) AssociateSpaceSupporterCalls(stub func(string, string, string, string, string) error) {
	fake.associateSpaceSupporterMutex.Lock()
	defer fake.associateSpaceSupporterMutex.Unlock()
	fake.AssociateSpaceSupporterStub = stub
}

func (fake *FakeManager) AssociateSpaceSupporterArgsForCall(i int) (string, string, string, string, string) {
	fake.associateSpaceSupporterMutex.RLock()
	defer fake.associateSpaceSupporterMutex.RUnlock()
	argsForCall := fake.associateSpaceSupporterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeManager) AssociateSpaceSupporterReturns(result1 error) {
	fake.associateSpaceSupporterMutex.Lock()
	defer fake.associateSpaceSupporterMutex.Unlock()
	fake.AssociateSpaceSupporterStub = nil
	fake.associateSpaceSupporterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AssociateSpaceSupporterReturnsOnCall(i int, result1 error) {
	fake.associateSpaceSupporterMutex.Lock()
	defer fake.associateSpaceSupporterMutex.Unlock()
	fake.AssociateSpaceSupporterStub = nil
	if fake.associateSpaceSupporterReturnsOnCall == nil {
		fake.associateSpaceSupporterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateSpaceSupporterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) ClearRoles() {
	fake.clearRolesMutex.Lock()
	fake.clearRolesArgsForCall = append(fake.clearRolesArgsForCall, struct {
	}{})
	stub := fake.ClearRolesStub
	fake.recordInvocation("ClearRoles", []interface{}{})
	fake.clearRolesMutex.Unlock()
	if stub != nil {
		fake.ClearRolesStub()
	}
}

func (fake *FakeManager) ClearRolesCallCount() int {
	fake.clearRolesMutex.RLock()
	defer fake.clearRolesMutex.RUnlock()
	return len(fake.clearRolesArgsForCall)
}

func (fake *FakeManager) ClearRolesCalls(stub func()) {
	fake.clearRolesMutex.Lock()
	defer fake.clearRolesMutex.Unlock()
	fake.ClearRolesStub = stub
}

func (fake *FakeManager) DeleteUser(arg1 string) error {
	fake.deleteUserMutex.Lock()
	ret, specificReturn := fake.deleteUserReturnsOnCall[len(fake.deleteUserArgsForCall)]
	fake.deleteUserArgsForCall = append(fake.deleteUserArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteUserStub
	fakeReturns := fake.deleteUserReturns
	fake.recordInvocation("DeleteUser", []interface{}{arg1})
	fake.deleteUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) DeleteUserCallCount() int {
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	return len(fake.deleteUserArgsForCall)
}

func (fake *FakeManager) DeleteUserCalls(stub func(string) error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = stub
}

func (fake *FakeManager) DeleteUserArgsForCall(i int) string {
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	argsForCall := fake.deleteUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) DeleteUserReturns(result1 error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = nil
	fake.deleteUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) DeleteUserReturnsOnCall(i int, result1 error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = nil
	if fake.deleteUserReturnsOnCall == nil {
		fake.deleteUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) ListOrgUsersByRole(arg1 string) (*role.RoleUsers, *role.RoleUsers, *role.RoleUsers, *role.RoleUsers, error) {
	fake.listOrgUsersByRoleMutex.Lock()
	ret, specificReturn := fake.listOrgUsersByRoleReturnsOnCall[len(fake.listOrgUsersByRoleArgsForCall)]
	fake.listOrgUsersByRoleArgsForCall = append(fake.listOrgUsersByRoleArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListOrgUsersByRoleStub
	fakeReturns := fake.listOrgUsersByRoleReturns
	fake.recordInvocation("ListOrgUsersByRole", []interface{}{arg1})
	fake.listOrgUsersByRoleMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4, ret.result5
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4, fakeReturns.result5
}

func (fake *FakeManager) ListOrgUsersByRoleCallCount() int {
	fake.listOrgUsersByRoleMutex.RLock()
	defer fake.listOrgUsersByRoleMutex.RUnlock()
	return len(fake.listOrgUsersByRoleArgsForCall)
}

func (fake *FakeManager) ListOrgUsersByRoleCalls(stub func(string) (*role.RoleUsers, *role.RoleUsers, *role.RoleUsers, *role.RoleUsers, error)) {
	fake.listOrgUsersByRoleMutex.Lock()
	defer fake.listOrgUsersByRoleMutex.Unlock()
	fake.ListOrgUsersByRoleStub = stub
}

func (fake *FakeManager) ListOrgUsersByRoleArgsForCall(i int) string {
	fake.listOrgUsersByRoleMutex.RLock()
	defer fake.listOrgUsersByRoleMutex.RUnlock()
	argsForCall := fake.listOrgUsersByRoleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) ListOrgUsersByRoleReturns(result1 *role.RoleUsers, result2 *role.RoleUsers, result3 *role.RoleUsers, result4 *role.RoleUsers, result5 error) {
	fake.listOrgUsersByRoleMutex.Lock()
	defer fake.listOrgUsersByRoleMutex.Unlock()
	fake.ListOrgUsersByRoleStub = nil
	fake.listOrgUsersByRoleReturns = struct {
		result1 *role.RoleUsers
		result2 *role.RoleUsers
		result3 *role.RoleUsers
		result4 *role.RoleUsers
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeManager) ListOrgUsersByRoleReturnsOnCall(i int, result1 *role.RoleUsers, result2 *role.RoleUsers, result3 *role.RoleUsers, result4 *role.RoleUsers, result5 error) {
	fake.listOrgUsersByRoleMutex.Lock()
	defer fake.listOrgUsersByRoleMutex.Unlock()
	fake.ListOrgUsersByRoleStub = nil
	if fake.listOrgUsersByRoleReturnsOnCall == nil {
		fake.listOrgUsersByRoleReturnsOnCall = make(map[int]struct {
			result1 *role.RoleUsers
			result2 *role.RoleUsers
			result3 *role.RoleUsers
			result4 *role.RoleUsers
			result5 error
		})
	}
	fake.listOrgUsersByRoleReturnsOnCall[i] = struct {
		result1 *role.RoleUsers
		result2 *role.RoleUsers
		result3 *role.RoleUsers
		result4 *role.RoleUsers
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeManager) ListSpaceUsersByRole(arg1 string) (*role.RoleUsers, *role.RoleUsers, *role.RoleUsers, *role.RoleUsers, error) {
	fake.listSpaceUsersByRoleMutex.Lock()
	ret, specificReturn := fake.listSpaceUsersByRoleReturnsOnCall[len(fake.listSpaceUsersByRoleArgsForCall)]
	fake.listSpaceUsersByRoleArgsForCall = append(fake.listSpaceUsersByRoleArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListSpaceUsersByRoleStub
	fakeReturns := fake.listSpaceUsersByRoleReturns
	fake.recordInvocation("ListSpaceUsersByRole", []interface{}{arg1})
	fake.listSpaceUsersByRoleMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4, ret.result5
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4, fakeReturns.result5
}

func (fake *FakeManager) ListSpaceUsersByRoleCallCount() int {
	fake.listSpaceUsersByRoleMutex.RLock()
	defer fake.listSpaceUsersByRoleMutex.RUnlock()
	return len(fake.listSpaceUsersByRoleArgsForCall)
}

func (fake *FakeManager) ListSpaceUsersByRoleCalls(stub func(string) (*role.RoleUsers, *role.RoleUsers, *role.RoleUsers, *role.RoleUsers, error)) {
	fake.listSpaceUsersByRoleMutex.Lock()
	defer fake.listSpaceUsersByRoleMutex.Unlock()
	fake.ListSpaceUsersByRoleStub = stub
}

func (fake *FakeManager) ListSpaceUsersByRoleArgsForCall(i int) string {
	fake.listSpaceUsersByRoleMutex.RLock()
	defer fake.listSpaceUsersByRoleMutex.RUnlock()
	argsForCall := fake.listSpaceUsersByRoleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) ListSpaceUsersByRoleReturns(result1 *role.RoleUsers, result2 *role.RoleUsers, result3 *role.RoleUsers, result4 *role.RoleUsers, result5 error) {
	fake.listSpaceUsersByRoleMutex.Lock()
	defer fake.listSpaceUsersByRoleMutex.Unlock()
	fake.ListSpaceUsersByRoleStub = nil
	fake.listSpaceUsersByRoleReturns = struct {
		result1 *role.RoleUsers
		result2 *role.RoleUsers
		result3 *role.RoleUsers
		result4 *role.RoleUsers
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeManager) ListSpaceUsersByRoleReturnsOnCall(i int, result1 *role.RoleUsers, result2 *role.RoleUsers, result3 *role.RoleUsers, result4 *role.RoleUsers, result5 error) {
	fake.listSpaceUsersByRoleMutex.Lock()
	defer fake.listSpaceUsersByRoleMutex.Unlock()
	fake.ListSpaceUsersByRoleStub = nil
	if fake.listSpaceUsersByRoleReturnsOnCall == nil {
		fake.listSpaceUsersByRoleReturnsOnCall = make(map[int]struct {
			result1 *role.RoleUsers
			result2 *role.RoleUsers
			result3 *role.RoleUsers
			result4 *role.RoleUsers
			result5 error
		})
	}
	fake.listSpaceUsersByRoleReturnsOnCall[i] = struct {
		result1 *role.RoleUsers
		result2 *role.RoleUsers
		result3 *role.RoleUsers
		result4 *role.RoleUsers
		result5 error
	}{result1, result2, result3, result4, result5}
}

func (fake *FakeManager) RemoveOrgAuditor(arg1 string, arg2 string, arg3 string, arg4 string) error {
	fake.removeOrgAuditorMutex.Lock()
	ret, specificReturn := fake.removeOrgAuditorReturnsOnCall[len(fake.removeOrgAuditorArgsForCall)]
	fake.removeOrgAuditorArgsForCall = append(fake.removeOrgAuditorArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveOrgAuditorStub
	fakeReturns := fake.removeOrgAuditorReturns
	fake.recordInvocation("RemoveOrgAuditor", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeOrgAuditorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) RemoveOrgAuditorCallCount() int {
	fake.removeOrgAuditorMutex.RLock()
	defer fake.removeOrgAuditorMutex.RUnlock()
	return len(fake.removeOrgAuditorArgsForCall)
}

func (fake *FakeManager) RemoveOrgAuditorCalls(stub func(string, string, string, string) error) {
	fake.removeOrgAuditorMutex.Lock()
	defer fake.removeOrgAuditorMutex.Unlock()
	fake.RemoveOrgAuditorStub = stub
}

func (fake *FakeManager) RemoveOrgAuditorArgsForCall(i int) (string, string, string, string) {
	fake.removeOrgAuditorMutex.RLock()
	defer fake.removeOrgAuditorMutex.RUnlock()
	argsForCall := fake.removeOrgAuditorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeManager) RemoveOrgAuditorReturns(result1 error) {
	fake.removeOrgAuditorMutex.Lock()
	defer fake.removeOrgAuditorMutex.Unlock()
	fake.RemoveOrgAuditorStub = nil
	fake.removeOrgAuditorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveOrgAuditorReturnsOnCall(i int, result1 error) {
	fake.removeOrgAuditorMutex.Lock()
	defer fake.removeOrgAuditorMutex.Unlock()
	fake.RemoveOrgAuditorStub = nil
	if fake.removeOrgAuditorReturnsOnCall == nil {
		fake.removeOrgAuditorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeOrgAuditorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveOrgBillingManager(arg1 string, arg2 string, arg3 string, arg4 string) error {
	fake.removeOrgBillingManagerMutex.Lock()
	ret, specificReturn := fake.removeOrgBillingManagerReturnsOnCall[len(fake.removeOrgBillingManagerArgsForCall)]
	fake.removeOrgBillingManagerArgsForCall = append(fake.removeOrgBillingManagerArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveOrgBillingManagerStub
	fakeReturns := fake.removeOrgBillingManagerReturns
	fake.recordInvocation("RemoveOrgBillingManager", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeOrgBillingManagerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) RemoveOrgBillingManagerCallCount() int {
	fake.removeOrgBillingManagerMutex.RLock()
	defer fake.removeOrgBillingManagerMutex.RUnlock()
	return len(fake.removeOrgBillingManagerArgsForCall)
}

func (fake *FakeManager) RemoveOrgBillingManagerCalls(stub func(string, string, string, string) error) {
	fake.removeOrgBillingManagerMutex.Lock()
	defer fake.removeOrgBillingManagerMutex.Unlock()
	fake.RemoveOrgBillingManagerStub = stub
}

func (fake *FakeManager) RemoveOrgBillingManagerArgsForCall(i int) (string, string, string, string) {
	fake.removeOrgBillingManagerMutex.RLock()
	defer fake.removeOrgBillingManagerMutex.RUnlock()
	argsForCall := fake.removeOrgBillingManagerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeManager) RemoveOrgBillingManagerReturns(result1 error) {
	fake.removeOrgBillingManagerMutex.Lock()
	defer fake.removeOrgBillingManagerMutex.Unlock()
	fake.RemoveOrgBillingManagerStub = nil
	fake.removeOrgBillingManagerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveOrgBillingManagerReturnsOnCall(i int, result1 error) {
	fake.removeOrgBillingManagerMutex.Lock()
	defer fake.removeOrgBillingManagerMutex.Unlock()
	fake.RemoveOrgBillingManagerStub = nil
	if fake.removeOrgBillingManagerReturnsOnCall == nil {
		fake.removeOrgBillingManagerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeOrgBillingManagerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveOrgManager(arg1 string, arg2 string, arg3 string, arg4 string) error {
	fake.removeOrgManagerMutex.Lock()
	ret, specificReturn := fake.removeOrgManagerReturnsOnCall[len(fake.removeOrgManagerArgsForCall)]
	fake.removeOrgManagerArgsForCall = append(fake.removeOrgManagerArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveOrgManagerStub
	fakeReturns := fake.removeOrgManagerReturns
	fake.recordInvocation("RemoveOrgManager", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeOrgManagerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) RemoveOrgManagerCallCount() int {
	fake.removeOrgManagerMutex.RLock()
	defer fake.removeOrgManagerMutex.RUnlock()
	return len(fake.removeOrgManagerArgsForCall)
}

func (fake *FakeManager) RemoveOrgManagerCalls(stub func(string, string, string, string) error) {
	fake.removeOrgManagerMutex.Lock()
	defer fake.removeOrgManagerMutex.Unlock()
	fake.RemoveOrgManagerStub = stub
}

func (fake *FakeManager) RemoveOrgManagerArgsForCall(i int) (string, string, string, string) {
	fake.removeOrgManagerMutex.RLock()
	defer fake.removeOrgManagerMutex.RUnlock()
	argsForCall := fake.removeOrgManagerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeManager) RemoveOrgManagerReturns(result1 error) {
	fake.removeOrgManagerMutex.Lock()
	defer fake.removeOrgManagerMutex.Unlock()
	fake.RemoveOrgManagerStub = nil
	fake.removeOrgManagerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveOrgManagerReturnsOnCall(i int, result1 error) {
	fake.removeOrgManagerMutex.Lock()
	defer fake.removeOrgManagerMutex.Unlock()
	fake.RemoveOrgManagerStub = nil
	if fake.removeOrgManagerReturnsOnCall == nil {
		fake.removeOrgManagerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeOrgManagerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveOrgUser(arg1 string, arg2 string, arg3 string, arg4 string) error {
	fake.removeOrgUserMutex.Lock()
	ret, specificReturn := fake.removeOrgUserReturnsOnCall[len(fake.removeOrgUserArgsForCall)]
	fake.removeOrgUserArgsForCall = append(fake.removeOrgUserArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveOrgUserStub
	fakeReturns := fake.removeOrgUserReturns
	fake.recordInvocation("RemoveOrgUser", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeOrgUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) RemoveOrgUserCallCount() int {
	fake.removeOrgUserMutex.RLock()
	defer fake.removeOrgUserMutex.RUnlock()
	return len(fake.removeOrgUserArgsForCall)
}

func (fake *FakeManager) RemoveOrgUserCalls(stub func(string, string, string, string) error) {
	fake.removeOrgUserMutex.Lock()
	defer fake.removeOrgUserMutex.Unlock()
	fake.RemoveOrgUserStub = stub
}

func (fake *FakeManager) RemoveOrgUserArgsForCall(i int) (string, string, string, string) {
	fake.removeOrgUserMutex.RLock()
	defer fake.removeOrgUserMutex.RUnlock()
	argsForCall := fake.removeOrgUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeManager) RemoveOrgUserReturns(result1 error) {
	fake.removeOrgUserMutex.Lock()
	defer fake.removeOrgUserMutex.Unlock()
	fake.RemoveOrgUserStub = nil
	fake.removeOrgUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveOrgUserReturnsOnCall(i int, result1 error) {
	fake.removeOrgUserMutex.Lock()
	defer fake.removeOrgUserMutex.Unlock()
	fake.RemoveOrgUserStub = nil
	if fake.removeOrgUserReturnsOnCall == nil {
		fake.removeOrgUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeOrgUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveSpaceAuditor(arg1 string, arg2 string, arg3 string, arg4 string) error {
	fake.removeSpaceAuditorMutex.Lock()
	ret, specificReturn := fake.removeSpaceAuditorReturnsOnCall[len(fake.removeSpaceAuditorArgsForCall)]
	fake.removeSpaceAuditorArgsForCall = append(fake.removeSpaceAuditorArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveSpaceAuditorStub
	fakeReturns := fake.removeSpaceAuditorReturns
	fake.recordInvocation("RemoveSpaceAuditor", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeSpaceAuditorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) RemoveSpaceAuditorCallCount() int {
	fake.removeSpaceAuditorMutex.RLock()
	defer fake.removeSpaceAuditorMutex.RUnlock()
	return len(fake.removeSpaceAuditorArgsForCall)
}

func (fake *FakeManager) RemoveSpaceAuditorCalls(stub func(string, string, string, string) error) {
	fake.removeSpaceAuditorMutex.Lock()
	defer fake.removeSpaceAuditorMutex.Unlock()
	fake.RemoveSpaceAuditorStub = stub
}

func (fake *FakeManager) RemoveSpaceAuditorArgsForCall(i int) (string, string, string, string) {
	fake.removeSpaceAuditorMutex.RLock()
	defer fake.removeSpaceAuditorMutex.RUnlock()
	argsForCall := fake.removeSpaceAuditorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeManager) RemoveSpaceAuditorReturns(result1 error) {
	fake.removeSpaceAuditorMutex.Lock()
	defer fake.removeSpaceAuditorMutex.Unlock()
	fake.RemoveSpaceAuditorStub = nil
	fake.removeSpaceAuditorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveSpaceAuditorReturnsOnCall(i int, result1 error) {
	fake.removeSpaceAuditorMutex.Lock()
	defer fake.removeSpaceAuditorMutex.Unlock()
	fake.RemoveSpaceAuditorStub = nil
	if fake.removeSpaceAuditorReturnsOnCall == nil {
		fake.removeSpaceAuditorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeSpaceAuditorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveSpaceDeveloper(arg1 string, arg2 string, arg3 string, arg4 string) error {
	fake.removeSpaceDeveloperMutex.Lock()
	ret, specificReturn := fake.removeSpaceDeveloperReturnsOnCall[len(fake.removeSpaceDeveloperArgsForCall)]
	fake.removeSpaceDeveloperArgsForCall = append(fake.removeSpaceDeveloperArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveSpaceDeveloperStub
	fakeReturns := fake.removeSpaceDeveloperReturns
	fake.recordInvocation("RemoveSpaceDeveloper", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeSpaceDeveloperMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) RemoveSpaceDeveloperCallCount() int {
	fake.removeSpaceDeveloperMutex.RLock()
	defer fake.removeSpaceDeveloperMutex.RUnlock()
	return len(fake.removeSpaceDeveloperArgsForCall)
}

func (fake *FakeManager) RemoveSpaceDeveloperCalls(stub func(string, string, string, string) error) {
	fake.removeSpaceDeveloperMutex.Lock()
	defer fake.removeSpaceDeveloperMutex.Unlock()
	fake.RemoveSpaceDeveloperStub = stub
}

func (fake *FakeManager) RemoveSpaceDeveloperArgsForCall(i int) (string, string, string, string) {
	fake.removeSpaceDeveloperMutex.RLock()
	defer fake.removeSpaceDeveloperMutex.RUnlock()
	argsForCall := fake.removeSpaceDeveloperArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeManager) RemoveSpaceDeveloperReturns(result1 error) {
	fake.removeSpaceDeveloperMutex.Lock()
	defer fake.removeSpaceDeveloperMutex.Unlock()
	fake.RemoveSpaceDeveloperStub = nil
	fake.removeSpaceDeveloperReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveSpaceDeveloperReturnsOnCall(i int, result1 error) {
	fake.removeSpaceDeveloperMutex.Lock()
	defer fake.removeSpaceDeveloperMutex.Unlock()
	fake.RemoveSpaceDeveloperStub = nil
	if fake.removeSpaceDeveloperReturnsOnCall == nil {
		fake.removeSpaceDeveloperReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeSpaceDeveloperReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveSpaceManager(arg1 string, arg2 string, arg3 string, arg4 string) error {
	fake.removeSpaceManagerMutex.Lock()
	ret, specificReturn := fake.removeSpaceManagerReturnsOnCall[len(fake.removeSpaceManagerArgsForCall)]
	fake.removeSpaceManagerArgsForCall = append(fake.removeSpaceManagerArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveSpaceManagerStub
	fakeReturns := fake.removeSpaceManagerReturns
	fake.recordInvocation("RemoveSpaceManager", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeSpaceManagerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) RemoveSpaceManagerCallCount() int {
	fake.removeSpaceManagerMutex.RLock()
	defer fake.removeSpaceManagerMutex.RUnlock()
	return len(fake.removeSpaceManagerArgsForCall)
}

func (fake *FakeManager) RemoveSpaceManagerCalls(stub func(string, string, string, string) error) {
	fake.removeSpaceManagerMutex.Lock()
	defer fake.removeSpaceManagerMutex.Unlock()
	fake.RemoveSpaceManagerStub = stub
}

func (fake *FakeManager) RemoveSpaceManagerArgsForCall(i int) (string, string, string, string) {
	fake.removeSpaceManagerMutex.RLock()
	defer fake.removeSpaceManagerMutex.RUnlock()
	argsForCall := fake.removeSpaceManagerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeManager) RemoveSpaceManagerReturns(result1 error) {
	fake.removeSpaceManagerMutex.Lock()
	defer fake.removeSpaceManagerMutex.Unlock()
	fake.RemoveSpaceManagerStub = nil
	fake.removeSpaceManagerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveSpaceManagerReturnsOnCall(i int, result1 error) {
	fake.removeSpaceManagerMutex.Lock()
	defer fake.removeSpaceManagerMutex.Unlock()
	fake.RemoveSpaceManagerStub = nil
	if fake.removeSpaceManagerReturnsOnCall == nil {
		fake.removeSpaceManagerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeSpaceManagerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveSpaceSupporter(arg1 string, arg2 string, arg3 string, arg4 string) error {
	fake.removeSpaceSupporterMutex.Lock()
	ret, specificReturn := fake.removeSpaceSupporterReturnsOnCall[len(fake.removeSpaceSupporterArgsForCall)]
	fake.removeSpaceSupporterArgsForCall = append(fake.removeSpaceSupporterArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveSpaceSupporterStub
	fakeReturns := fake.removeSpaceSupporterReturns
	fake.recordInvocation("RemoveSpaceSupporter", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeSpaceSupporterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) RemoveSpaceSupporterCallCount() int {
	fake.removeSpaceSupporterMutex.RLock()
	defer fake.removeSpaceSupporterMutex.RUnlock()
	return len(fake.removeSpaceSupporterArgsForCall)
}

func (fake *FakeManager) RemoveSpaceSupporterCalls(stub func(string, string, string, string) error) {
	fake.removeSpaceSupporterMutex.Lock()
	defer fake.removeSpaceSupporterMutex.Unlock()
	fake.RemoveSpaceSupporterStub = stub
}

func (fake *FakeManager) RemoveSpaceSupporterArgsForCall(i int) (string, string, string, string) {
	fake.removeSpaceSupporterMutex.RLock()
	defer fake.removeSpaceSupporterMutex.RUnlock()
	argsForCall := fake.removeSpaceSupporterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeManager) RemoveSpaceSupporterReturns(result1 error) {
	fake.removeSpaceSupporterMutex.Lock()
	defer fake.removeSpaceSupporterMutex.Unlock()
	fake.RemoveSpaceSupporterStub = nil
	fake.removeSpaceSupporterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) RemoveSpaceSupporterReturnsOnCall(i int, result1 error) {
	fake.removeSpaceSupporterMutex.Lock()
	defer fake.removeSpaceSupporterMutex.Unlock()
	fake.RemoveSpaceSupporterStub = nil
	if fake.removeSpaceSupporterReturnsOnCall == nil {
		fake.removeSpaceSupporterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeSpaceSupporterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.associateOrgAuditorMutex.RLock()
	defer fake.associateOrgAuditorMutex.RUnlock()
	fake.associateOrgBillingManagerMutex.RLock()
	defer fake.associateOrgBillingManagerMutex.RUnlock()
	fake.associateOrgManagerMutex.RLock()
	defer fake.associateOrgManagerMutex.RUnlock()
	fake.associateSpaceAuditorMutex.RLock()
	defer fake.associateSpaceAuditorMutex.RUnlock()
	fake.associateSpaceDeveloperMutex.RLock()
	defer fake.associateSpaceDeveloperMutex.RUnlock()
	fake.associateSpaceManagerMutex.RLock()
	defer fake.associateSpaceManagerMutex.RUnlock()
	fake.associateSpaceSupporterMutex.RLock()
	defer fake.associateSpaceSupporterMutex.RUnlock()
	fake.clearRolesMutex.RLock()
	defer fake.clearRolesMutex.RUnlock()
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	fake.listOrgUsersByRoleMutex.RLock()
	defer fake.listOrgUsersByRoleMutex.RUnlock()
	fake.listSpaceUsersByRoleMutex.RLock()
	defer fake.listSpaceUsersByRoleMutex.RUnlock()
	fake.removeOrgAuditorMutex.RLock()
	defer fake.removeOrgAuditorMutex.RUnlock()
	fake.removeOrgBillingManagerMutex.RLock()
	defer fake.removeOrgBillingManagerMutex.RUnlock()
	fake.removeOrgManagerMutex.RLock()
	defer fake.removeOrgManagerMutex.RUnlock()
	fake.removeOrgUserMutex.RLock()
	defer fake.removeOrgUserMutex.RUnlock()
	fake.removeSpaceAuditorMutex.RLock()
	defer fake.removeSpaceAuditorMutex.RUnlock()
	fake.removeSpaceDeveloperMutex.RLock()
	defer fake.removeSpaceDeveloperMutex.RUnlock()
	fake.removeSpaceManagerMutex.RLock()
	defer fake.removeSpaceManagerMutex.RUnlock()
	fake.removeSpaceSupporterMutex.RLock()
	defer fake.removeSpaceSupporterMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ role.Manager = new(FakeManager)
