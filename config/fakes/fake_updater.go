// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/vmwarepivotallabs/cf-mgmt/config"
)

type FakeUpdater struct {
	AddDefaultSecurityGroupStub        func(string, []byte) error
	addDefaultSecurityGroupMutex       sync.RWMutex
	addDefaultSecurityGroupArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	addDefaultSecurityGroupReturns struct {
		result1 error
	}
	addDefaultSecurityGroupReturnsOnCall map[int]struct {
		result1 error
	}
	AddOrgQuotaStub        func(config.OrgQuota) error
	addOrgQuotaMutex       sync.RWMutex
	addOrgQuotaArgsForCall []struct {
		arg1 config.OrgQuota
	}
	addOrgQuotaReturns struct {
		result1 error
	}
	addOrgQuotaReturnsOnCall map[int]struct {
		result1 error
	}
	AddOrgToConfigStub        func(*config.OrgConfig) error
	addOrgToConfigMutex       sync.RWMutex
	addOrgToConfigArgsForCall []struct {
		arg1 *config.OrgConfig
	}
	addOrgToConfigReturns struct {
		result1 error
	}
	addOrgToConfigReturnsOnCall map[int]struct {
		result1 error
	}
	AddSecurityGroupStub        func(string, []byte) error
	addSecurityGroupMutex       sync.RWMutex
	addSecurityGroupArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	addSecurityGroupReturns struct {
		result1 error
	}
	addSecurityGroupReturnsOnCall map[int]struct {
		result1 error
	}
	AddSecurityGroupToSpaceStub        func(string, string, []byte) error
	addSecurityGroupToSpaceMutex       sync.RWMutex
	addSecurityGroupToSpaceArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []byte
	}
	addSecurityGroupToSpaceReturns struct {
		result1 error
	}
	addSecurityGroupToSpaceReturnsOnCall map[int]struct {
		result1 error
	}
	AddSpaceQuotaStub        func(config.SpaceQuota) error
	addSpaceQuotaMutex       sync.RWMutex
	addSpaceQuotaArgsForCall []struct {
		arg1 config.SpaceQuota
	}
	addSpaceQuotaReturns struct {
		result1 error
	}
	addSpaceQuotaReturnsOnCall map[int]struct {
		result1 error
	}
	AddSpaceToConfigStub        func(*config.SpaceConfig) error
	addSpaceToConfigMutex       sync.RWMutex
	addSpaceToConfigArgsForCall []struct {
		arg1 *config.SpaceConfig
	}
	addSpaceToConfigReturns struct {
		result1 error
	}
	addSpaceToConfigReturnsOnCall map[int]struct {
		result1 error
	}
	AssociateOrgAuditorStub        func(config.UserOrigin, string, string) error
	associateOrgAuditorMutex       sync.RWMutex
	associateOrgAuditorArgsForCall []struct {
		arg1 config.UserOrigin
		arg2 string
		arg3 string
	}
	associateOrgAuditorReturns struct {
		result1 error
	}
	associateOrgAuditorReturnsOnCall map[int]struct {
		result1 error
	}
	AssociateSpaceAuditorStub        func(config.UserOrigin, string, string, string) error
	associateSpaceAuditorMutex       sync.RWMutex
	associateSpaceAuditorArgsForCall []struct {
		arg1 config.UserOrigin
		arg2 string
		arg3 string
		arg4 string
	}
	associateSpaceAuditorReturns struct {
		result1 error
	}
	associateSpaceAuditorReturnsOnCall map[int]struct {
		result1 error
	}
	AssociateSpaceDeveloperStub        func(config.UserOrigin, string, string, string) error
	associateSpaceDeveloperMutex       sync.RWMutex
	associateSpaceDeveloperArgsForCall []struct {
		arg1 config.UserOrigin
		arg2 string
		arg3 string
		arg4 string
	}
	associateSpaceDeveloperReturns struct {
		result1 error
	}
	associateSpaceDeveloperReturnsOnCall map[int]struct {
		result1 error
	}
	CreateConfigIfNotExistsStub        func(string) error
	createConfigIfNotExistsMutex       sync.RWMutex
	createConfigIfNotExistsArgsForCall []struct {
		arg1 string
	}
	createConfigIfNotExistsReturns struct {
		result1 error
	}
	createConfigIfNotExistsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteConfigIfExistsStub        func() error
	deleteConfigIfExistsMutex       sync.RWMutex
	deleteConfigIfExistsArgsForCall []struct {
	}
	deleteConfigIfExistsReturns struct {
		result1 error
	}
	deleteConfigIfExistsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteOrgConfigStub        func(string) error
	deleteOrgConfigMutex       sync.RWMutex
	deleteOrgConfigArgsForCall []struct {
		arg1 string
	}
	deleteOrgConfigReturns struct {
		result1 error
	}
	deleteOrgConfigReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteSpaceConfigStub        func(string, string) error
	deleteSpaceConfigMutex       sync.RWMutex
	deleteSpaceConfigArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteSpaceConfigReturns struct {
		result1 error
	}
	deleteSpaceConfigReturnsOnCall map[int]struct {
		result1 error
	}
	RenameOrgConfigStub        func(*config.OrgConfig) error
	renameOrgConfigMutex       sync.RWMutex
	renameOrgConfigArgsForCall []struct {
		arg1 *config.OrgConfig
	}
	renameOrgConfigReturns struct {
		result1 error
	}
	renameOrgConfigReturnsOnCall map[int]struct {
		result1 error
	}
	RenameSpaceConfigStub        func(*config.SpaceConfig) error
	renameSpaceConfigMutex       sync.RWMutex
	renameSpaceConfigArgsForCall []struct {
		arg1 *config.SpaceConfig
	}
	renameSpaceConfigReturns struct {
		result1 error
	}
	renameSpaceConfigReturnsOnCall map[int]struct {
		result1 error
	}
	SaveGlobalConfigStub        func(*config.GlobalConfig) error
	saveGlobalConfigMutex       sync.RWMutex
	saveGlobalConfigArgsForCall []struct {
		arg1 *config.GlobalConfig
	}
	saveGlobalConfigReturns struct {
		result1 error
	}
	saveGlobalConfigReturnsOnCall map[int]struct {
		result1 error
	}
	SaveOrgConfigStub        func(*config.OrgConfig) error
	saveOrgConfigMutex       sync.RWMutex
	saveOrgConfigArgsForCall []struct {
		arg1 *config.OrgConfig
	}
	saveOrgConfigReturns struct {
		result1 error
	}
	saveOrgConfigReturnsOnCall map[int]struct {
		result1 error
	}
	SaveOrgQuotaStub        func(*config.OrgQuota) error
	saveOrgQuotaMutex       sync.RWMutex
	saveOrgQuotaArgsForCall []struct {
		arg1 *config.OrgQuota
	}
	saveOrgQuotaReturns struct {
		result1 error
	}
	saveOrgQuotaReturnsOnCall map[int]struct {
		result1 error
	}
	SaveOrgSpacesStub        func(*config.Spaces) error
	saveOrgSpacesMutex       sync.RWMutex
	saveOrgSpacesArgsForCall []struct {
		arg1 *config.Spaces
	}
	saveOrgSpacesReturns struct {
		result1 error
	}
	saveOrgSpacesReturnsOnCall map[int]struct {
		result1 error
	}
	SaveOrgsStub        func(*config.Orgs) error
	saveOrgsMutex       sync.RWMutex
	saveOrgsArgsForCall []struct {
		arg1 *config.Orgs
	}
	saveOrgsReturns struct {
		result1 error
	}
	saveOrgsReturnsOnCall map[int]struct {
		result1 error
	}
	SaveSpaceConfigStub        func(*config.SpaceConfig) error
	saveSpaceConfigMutex       sync.RWMutex
	saveSpaceConfigArgsForCall []struct {
		arg1 *config.SpaceConfig
	}
	saveSpaceConfigReturns struct {
		result1 error
	}
	saveSpaceConfigReturnsOnCall map[int]struct {
		result1 error
	}
	SaveSpaceQuotaStub        func(*config.SpaceQuota) error
	saveSpaceQuotaMutex       sync.RWMutex
	saveSpaceQuotaArgsForCall []struct {
		arg1 *config.SpaceQuota
	}
	saveSpaceQuotaReturns struct {
		result1 error
	}
	saveSpaceQuotaReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUpdater) AddDefaultSecurityGroup(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.addDefaultSecurityGroupMutex.Lock()
	ret, specificReturn := fake.addDefaultSecurityGroupReturnsOnCall[len(fake.addDefaultSecurityGroupArgsForCall)]
	fake.addDefaultSecurityGroupArgsForCall = append(fake.addDefaultSecurityGroupArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.AddDefaultSecurityGroupStub
	fakeReturns := fake.addDefaultSecurityGroupReturns
	fake.recordInvocation("AddDefaultSecurityGroup", []interface{}{arg1, arg2Copy})
	fake.addDefaultSecurityGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) AddDefaultSecurityGroupCallCount() int {
	fake.addDefaultSecurityGroupMutex.RLock()
	defer fake.addDefaultSecurityGroupMutex.RUnlock()
	return len(fake.addDefaultSecurityGroupArgsForCall)
}

func (fake *FakeUpdater) AddDefaultSecurityGroupCalls(stub func(string, []byte) error) {
	fake.addDefaultSecurityGroupMutex.Lock()
	defer fake.addDefaultSecurityGroupMutex.Unlock()
	fake.AddDefaultSecurityGroupStub = stub
}

func (fake *FakeUpdater) AddDefaultSecurityGroupArgsForCall(i int) (string, []byte) {
	fake.addDefaultSecurityGroupMutex.RLock()
	defer fake.addDefaultSecurityGroupMutex.RUnlock()
	argsForCall := fake.addDefaultSecurityGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUpdater) AddDefaultSecurityGroupReturns(result1 error) {
	fake.addDefaultSecurityGroupMutex.Lock()
	defer fake.addDefaultSecurityGroupMutex.Unlock()
	fake.AddDefaultSecurityGroupStub = nil
	fake.addDefaultSecurityGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddDefaultSecurityGroupReturnsOnCall(i int, result1 error) {
	fake.addDefaultSecurityGroupMutex.Lock()
	defer fake.addDefaultSecurityGroupMutex.Unlock()
	fake.AddDefaultSecurityGroupStub = nil
	if fake.addDefaultSecurityGroupReturnsOnCall == nil {
		fake.addDefaultSecurityGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addDefaultSecurityGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddOrgQuota(arg1 config.OrgQuota) error {
	fake.addOrgQuotaMutex.Lock()
	ret, specificReturn := fake.addOrgQuotaReturnsOnCall[len(fake.addOrgQuotaArgsForCall)]
	fake.addOrgQuotaArgsForCall = append(fake.addOrgQuotaArgsForCall, struct {
		arg1 config.OrgQuota
	}{arg1})
	stub := fake.AddOrgQuotaStub
	fakeReturns := fake.addOrgQuotaReturns
	fake.recordInvocation("AddOrgQuota", []interface{}{arg1})
	fake.addOrgQuotaMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) AddOrgQuotaCallCount() int {
	fake.addOrgQuotaMutex.RLock()
	defer fake.addOrgQuotaMutex.RUnlock()
	return len(fake.addOrgQuotaArgsForCall)
}

func (fake *FakeUpdater) AddOrgQuotaCalls(stub func(config.OrgQuota) error) {
	fake.addOrgQuotaMutex.Lock()
	defer fake.addOrgQuotaMutex.Unlock()
	fake.AddOrgQuotaStub = stub
}

func (fake *FakeUpdater) AddOrgQuotaArgsForCall(i int) config.OrgQuota {
	fake.addOrgQuotaMutex.RLock()
	defer fake.addOrgQuotaMutex.RUnlock()
	argsForCall := fake.addOrgQuotaArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) AddOrgQuotaReturns(result1 error) {
	fake.addOrgQuotaMutex.Lock()
	defer fake.addOrgQuotaMutex.Unlock()
	fake.AddOrgQuotaStub = nil
	fake.addOrgQuotaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddOrgQuotaReturnsOnCall(i int, result1 error) {
	fake.addOrgQuotaMutex.Lock()
	defer fake.addOrgQuotaMutex.Unlock()
	fake.AddOrgQuotaStub = nil
	if fake.addOrgQuotaReturnsOnCall == nil {
		fake.addOrgQuotaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addOrgQuotaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddOrgToConfig(arg1 *config.OrgConfig) error {
	fake.addOrgToConfigMutex.Lock()
	ret, specificReturn := fake.addOrgToConfigReturnsOnCall[len(fake.addOrgToConfigArgsForCall)]
	fake.addOrgToConfigArgsForCall = append(fake.addOrgToConfigArgsForCall, struct {
		arg1 *config.OrgConfig
	}{arg1})
	stub := fake.AddOrgToConfigStub
	fakeReturns := fake.addOrgToConfigReturns
	fake.recordInvocation("AddOrgToConfig", []interface{}{arg1})
	fake.addOrgToConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) AddOrgToConfigCallCount() int {
	fake.addOrgToConfigMutex.RLock()
	defer fake.addOrgToConfigMutex.RUnlock()
	return len(fake.addOrgToConfigArgsForCall)
}

func (fake *FakeUpdater) AddOrgToConfigCalls(stub func(*config.OrgConfig) error) {
	fake.addOrgToConfigMutex.Lock()
	defer fake.addOrgToConfigMutex.Unlock()
	fake.AddOrgToConfigStub = stub
}

func (fake *FakeUpdater) AddOrgToConfigArgsForCall(i int) *config.OrgConfig {
	fake.addOrgToConfigMutex.RLock()
	defer fake.addOrgToConfigMutex.RUnlock()
	argsForCall := fake.addOrgToConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) AddOrgToConfigReturns(result1 error) {
	fake.addOrgToConfigMutex.Lock()
	defer fake.addOrgToConfigMutex.Unlock()
	fake.AddOrgToConfigStub = nil
	fake.addOrgToConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddOrgToConfigReturnsOnCall(i int, result1 error) {
	fake.addOrgToConfigMutex.Lock()
	defer fake.addOrgToConfigMutex.Unlock()
	fake.AddOrgToConfigStub = nil
	if fake.addOrgToConfigReturnsOnCall == nil {
		fake.addOrgToConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addOrgToConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddSecurityGroup(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.addSecurityGroupMutex.Lock()
	ret, specificReturn := fake.addSecurityGroupReturnsOnCall[len(fake.addSecurityGroupArgsForCall)]
	fake.addSecurityGroupArgsForCall = append(fake.addSecurityGroupArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.AddSecurityGroupStub
	fakeReturns := fake.addSecurityGroupReturns
	fake.recordInvocation("AddSecurityGroup", []interface{}{arg1, arg2Copy})
	fake.addSecurityGroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) AddSecurityGroupCallCount() int {
	fake.addSecurityGroupMutex.RLock()
	defer fake.addSecurityGroupMutex.RUnlock()
	return len(fake.addSecurityGroupArgsForCall)
}

func (fake *FakeUpdater) AddSecurityGroupCalls(stub func(string, []byte) error) {
	fake.addSecurityGroupMutex.Lock()
	defer fake.addSecurityGroupMutex.Unlock()
	fake.AddSecurityGroupStub = stub
}

func (fake *FakeUpdater) AddSecurityGroupArgsForCall(i int) (string, []byte) {
	fake.addSecurityGroupMutex.RLock()
	defer fake.addSecurityGroupMutex.RUnlock()
	argsForCall := fake.addSecurityGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUpdater) AddSecurityGroupReturns(result1 error) {
	fake.addSecurityGroupMutex.Lock()
	defer fake.addSecurityGroupMutex.Unlock()
	fake.AddSecurityGroupStub = nil
	fake.addSecurityGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddSecurityGroupReturnsOnCall(i int, result1 error) {
	fake.addSecurityGroupMutex.Lock()
	defer fake.addSecurityGroupMutex.Unlock()
	fake.AddSecurityGroupStub = nil
	if fake.addSecurityGroupReturnsOnCall == nil {
		fake.addSecurityGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addSecurityGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddSecurityGroupToSpace(arg1 string, arg2 string, arg3 []byte) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.addSecurityGroupToSpaceMutex.Lock()
	ret, specificReturn := fake.addSecurityGroupToSpaceReturnsOnCall[len(fake.addSecurityGroupToSpaceArgsForCall)]
	fake.addSecurityGroupToSpaceArgsForCall = append(fake.addSecurityGroupToSpaceArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.AddSecurityGroupToSpaceStub
	fakeReturns := fake.addSecurityGroupToSpaceReturns
	fake.recordInvocation("AddSecurityGroupToSpace", []interface{}{arg1, arg2, arg3Copy})
	fake.addSecurityGroupToSpaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) AddSecurityGroupToSpaceCallCount() int {
	fake.addSecurityGroupToSpaceMutex.RLock()
	defer fake.addSecurityGroupToSpaceMutex.RUnlock()
	return len(fake.addSecurityGroupToSpaceArgsForCall)
}

func (fake *FakeUpdater) AddSecurityGroupToSpaceCalls(stub func(string, string, []byte) error) {
	fake.addSecurityGroupToSpaceMutex.Lock()
	defer fake.addSecurityGroupToSpaceMutex.Unlock()
	fake.AddSecurityGroupToSpaceStub = stub
}

func (fake *FakeUpdater) AddSecurityGroupToSpaceArgsForCall(i int) (string, string, []byte) {
	fake.addSecurityGroupToSpaceMutex.RLock()
	defer fake.addSecurityGroupToSpaceMutex.RUnlock()
	argsForCall := fake.addSecurityGroupToSpaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUpdater) AddSecurityGroupToSpaceReturns(result1 error) {
	fake.addSecurityGroupToSpaceMutex.Lock()
	defer fake.addSecurityGroupToSpaceMutex.Unlock()
	fake.AddSecurityGroupToSpaceStub = nil
	fake.addSecurityGroupToSpaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddSecurityGroupToSpaceReturnsOnCall(i int, result1 error) {
	fake.addSecurityGroupToSpaceMutex.Lock()
	defer fake.addSecurityGroupToSpaceMutex.Unlock()
	fake.AddSecurityGroupToSpaceStub = nil
	if fake.addSecurityGroupToSpaceReturnsOnCall == nil {
		fake.addSecurityGroupToSpaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addSecurityGroupToSpaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddSpaceQuota(arg1 config.SpaceQuota) error {
	fake.addSpaceQuotaMutex.Lock()
	ret, specificReturn := fake.addSpaceQuotaReturnsOnCall[len(fake.addSpaceQuotaArgsForCall)]
	fake.addSpaceQuotaArgsForCall = append(fake.addSpaceQuotaArgsForCall, struct {
		arg1 config.SpaceQuota
	}{arg1})
	stub := fake.AddSpaceQuotaStub
	fakeReturns := fake.addSpaceQuotaReturns
	fake.recordInvocation("AddSpaceQuota", []interface{}{arg1})
	fake.addSpaceQuotaMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) AddSpaceQuotaCallCount() int {
	fake.addSpaceQuotaMutex.RLock()
	defer fake.addSpaceQuotaMutex.RUnlock()
	return len(fake.addSpaceQuotaArgsForCall)
}

func (fake *FakeUpdater) AddSpaceQuotaCalls(stub func(config.SpaceQuota) error) {
	fake.addSpaceQuotaMutex.Lock()
	defer fake.addSpaceQuotaMutex.Unlock()
	fake.AddSpaceQuotaStub = stub
}

func (fake *FakeUpdater) AddSpaceQuotaArgsForCall(i int) config.SpaceQuota {
	fake.addSpaceQuotaMutex.RLock()
	defer fake.addSpaceQuotaMutex.RUnlock()
	argsForCall := fake.addSpaceQuotaArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) AddSpaceQuotaReturns(result1 error) {
	fake.addSpaceQuotaMutex.Lock()
	defer fake.addSpaceQuotaMutex.Unlock()
	fake.AddSpaceQuotaStub = nil
	fake.addSpaceQuotaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddSpaceQuotaReturnsOnCall(i int, result1 error) {
	fake.addSpaceQuotaMutex.Lock()
	defer fake.addSpaceQuotaMutex.Unlock()
	fake.AddSpaceQuotaStub = nil
	if fake.addSpaceQuotaReturnsOnCall == nil {
		fake.addSpaceQuotaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addSpaceQuotaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddSpaceToConfig(arg1 *config.SpaceConfig) error {
	fake.addSpaceToConfigMutex.Lock()
	ret, specificReturn := fake.addSpaceToConfigReturnsOnCall[len(fake.addSpaceToConfigArgsForCall)]
	fake.addSpaceToConfigArgsForCall = append(fake.addSpaceToConfigArgsForCall, struct {
		arg1 *config.SpaceConfig
	}{arg1})
	stub := fake.AddSpaceToConfigStub
	fakeReturns := fake.addSpaceToConfigReturns
	fake.recordInvocation("AddSpaceToConfig", []interface{}{arg1})
	fake.addSpaceToConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) AddSpaceToConfigCallCount() int {
	fake.addSpaceToConfigMutex.RLock()
	defer fake.addSpaceToConfigMutex.RUnlock()
	return len(fake.addSpaceToConfigArgsForCall)
}

func (fake *FakeUpdater) AddSpaceToConfigCalls(stub func(*config.SpaceConfig) error) {
	fake.addSpaceToConfigMutex.Lock()
	defer fake.addSpaceToConfigMutex.Unlock()
	fake.AddSpaceToConfigStub = stub
}

func (fake *FakeUpdater) AddSpaceToConfigArgsForCall(i int) *config.SpaceConfig {
	fake.addSpaceToConfigMutex.RLock()
	defer fake.addSpaceToConfigMutex.RUnlock()
	argsForCall := fake.addSpaceToConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) AddSpaceToConfigReturns(result1 error) {
	fake.addSpaceToConfigMutex.Lock()
	defer fake.addSpaceToConfigMutex.Unlock()
	fake.AddSpaceToConfigStub = nil
	fake.addSpaceToConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AddSpaceToConfigReturnsOnCall(i int, result1 error) {
	fake.addSpaceToConfigMutex.Lock()
	defer fake.addSpaceToConfigMutex.Unlock()
	fake.AddSpaceToConfigStub = nil
	if fake.addSpaceToConfigReturnsOnCall == nil {
		fake.addSpaceToConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addSpaceToConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AssociateOrgAuditor(arg1 config.UserOrigin, arg2 string, arg3 string) error {
	fake.associateOrgAuditorMutex.Lock()
	ret, specificReturn := fake.associateOrgAuditorReturnsOnCall[len(fake.associateOrgAuditorArgsForCall)]
	fake.associateOrgAuditorArgsForCall = append(fake.associateOrgAuditorArgsForCall, struct {
		arg1 config.UserOrigin
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AssociateOrgAuditorStub
	fakeReturns := fake.associateOrgAuditorReturns
	fake.recordInvocation("AssociateOrgAuditor", []interface{}{arg1, arg2, arg3})
	fake.associateOrgAuditorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) AssociateOrgAuditorCallCount() int {
	fake.associateOrgAuditorMutex.RLock()
	defer fake.associateOrgAuditorMutex.RUnlock()
	return len(fake.associateOrgAuditorArgsForCall)
}

func (fake *FakeUpdater) AssociateOrgAuditorCalls(stub func(config.UserOrigin, string, string) error) {
	fake.associateOrgAuditorMutex.Lock()
	defer fake.associateOrgAuditorMutex.Unlock()
	fake.AssociateOrgAuditorStub = stub
}

func (fake *FakeUpdater) AssociateOrgAuditorArgsForCall(i int) (config.UserOrigin, string, string) {
	fake.associateOrgAuditorMutex.RLock()
	defer fake.associateOrgAuditorMutex.RUnlock()
	argsForCall := fake.associateOrgAuditorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUpdater) AssociateOrgAuditorReturns(result1 error) {
	fake.associateOrgAuditorMutex.Lock()
	defer fake.associateOrgAuditorMutex.Unlock()
	fake.AssociateOrgAuditorStub = nil
	fake.associateOrgAuditorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AssociateOrgAuditorReturnsOnCall(i int, result1 error) {
	fake.associateOrgAuditorMutex.Lock()
	defer fake.associateOrgAuditorMutex.Unlock()
	fake.AssociateOrgAuditorStub = nil
	if fake.associateOrgAuditorReturnsOnCall == nil {
		fake.associateOrgAuditorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateOrgAuditorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AssociateSpaceAuditor(arg1 config.UserOrigin, arg2 string, arg3 string, arg4 string) error {
	fake.associateSpaceAuditorMutex.Lock()
	ret, specificReturn := fake.associateSpaceAuditorReturnsOnCall[len(fake.associateSpaceAuditorArgsForCall)]
	fake.associateSpaceAuditorArgsForCall = append(fake.associateSpaceAuditorArgsForCall, struct {
		arg1 config.UserOrigin
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.AssociateSpaceAuditorStub
	fakeReturns := fake.associateSpaceAuditorReturns
	fake.recordInvocation("AssociateSpaceAuditor", []interface{}{arg1, arg2, arg3, arg4})
	fake.associateSpaceAuditorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) AssociateSpaceAuditorCallCount() int {
	fake.associateSpaceAuditorMutex.RLock()
	defer fake.associateSpaceAuditorMutex.RUnlock()
	return len(fake.associateSpaceAuditorArgsForCall)
}

func (fake *FakeUpdater) AssociateSpaceAuditorCalls(stub func(config.UserOrigin, string, string, string) error) {
	fake.associateSpaceAuditorMutex.Lock()
	defer fake.associateSpaceAuditorMutex.Unlock()
	fake.AssociateSpaceAuditorStub = stub
}

func (fake *FakeUpdater) AssociateSpaceAuditorArgsForCall(i int) (config.UserOrigin, string, string, string) {
	fake.associateSpaceAuditorMutex.RLock()
	defer fake.associateSpaceAuditorMutex.RUnlock()
	argsForCall := fake.associateSpaceAuditorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeUpdater) AssociateSpaceAuditorReturns(result1 error) {
	fake.associateSpaceAuditorMutex.Lock()
	defer fake.associateSpaceAuditorMutex.Unlock()
	fake.AssociateSpaceAuditorStub = nil
	fake.associateSpaceAuditorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AssociateSpaceAuditorReturnsOnCall(i int, result1 error) {
	fake.associateSpaceAuditorMutex.Lock()
	defer fake.associateSpaceAuditorMutex.Unlock()
	fake.AssociateSpaceAuditorStub = nil
	if fake.associateSpaceAuditorReturnsOnCall == nil {
		fake.associateSpaceAuditorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateSpaceAuditorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AssociateSpaceDeveloper(arg1 config.UserOrigin, arg2 string, arg3 string, arg4 string) error {
	fake.associateSpaceDeveloperMutex.Lock()
	ret, specificReturn := fake.associateSpaceDeveloperReturnsOnCall[len(fake.associateSpaceDeveloperArgsForCall)]
	fake.associateSpaceDeveloperArgsForCall = append(fake.associateSpaceDeveloperArgsForCall, struct {
		arg1 config.UserOrigin
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.AssociateSpaceDeveloperStub
	fakeReturns := fake.associateSpaceDeveloperReturns
	fake.recordInvocation("AssociateSpaceDeveloper", []interface{}{arg1, arg2, arg3, arg4})
	fake.associateSpaceDeveloperMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) AssociateSpaceDeveloperCallCount() int {
	fake.associateSpaceDeveloperMutex.RLock()
	defer fake.associateSpaceDeveloperMutex.RUnlock()
	return len(fake.associateSpaceDeveloperArgsForCall)
}

func (fake *FakeUpdater) AssociateSpaceDeveloperCalls(stub func(config.UserOrigin, string, string, string) error) {
	fake.associateSpaceDeveloperMutex.Lock()
	defer fake.associateSpaceDeveloperMutex.Unlock()
	fake.AssociateSpaceDeveloperStub = stub
}

func (fake *FakeUpdater) AssociateSpaceDeveloperArgsForCall(i int) (config.UserOrigin, string, string, string) {
	fake.associateSpaceDeveloperMutex.RLock()
	defer fake.associateSpaceDeveloperMutex.RUnlock()
	argsForCall := fake.associateSpaceDeveloperArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeUpdater) AssociateSpaceDeveloperReturns(result1 error) {
	fake.associateSpaceDeveloperMutex.Lock()
	defer fake.associateSpaceDeveloperMutex.Unlock()
	fake.AssociateSpaceDeveloperStub = nil
	fake.associateSpaceDeveloperReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) AssociateSpaceDeveloperReturnsOnCall(i int, result1 error) {
	fake.associateSpaceDeveloperMutex.Lock()
	defer fake.associateSpaceDeveloperMutex.Unlock()
	fake.AssociateSpaceDeveloperStub = nil
	if fake.associateSpaceDeveloperReturnsOnCall == nil {
		fake.associateSpaceDeveloperReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateSpaceDeveloperReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) CreateConfigIfNotExists(arg1 string) error {
	fake.createConfigIfNotExistsMutex.Lock()
	ret, specificReturn := fake.createConfigIfNotExistsReturnsOnCall[len(fake.createConfigIfNotExistsArgsForCall)]
	fake.createConfigIfNotExistsArgsForCall = append(fake.createConfigIfNotExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CreateConfigIfNotExistsStub
	fakeReturns := fake.createConfigIfNotExistsReturns
	fake.recordInvocation("CreateConfigIfNotExists", []interface{}{arg1})
	fake.createConfigIfNotExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) CreateConfigIfNotExistsCallCount() int {
	fake.createConfigIfNotExistsMutex.RLock()
	defer fake.createConfigIfNotExistsMutex.RUnlock()
	return len(fake.createConfigIfNotExistsArgsForCall)
}

func (fake *FakeUpdater) CreateConfigIfNotExistsCalls(stub func(string) error) {
	fake.createConfigIfNotExistsMutex.Lock()
	defer fake.createConfigIfNotExistsMutex.Unlock()
	fake.CreateConfigIfNotExistsStub = stub
}

func (fake *FakeUpdater) CreateConfigIfNotExistsArgsForCall(i int) string {
	fake.createConfigIfNotExistsMutex.RLock()
	defer fake.createConfigIfNotExistsMutex.RUnlock()
	argsForCall := fake.createConfigIfNotExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) CreateConfigIfNotExistsReturns(result1 error) {
	fake.createConfigIfNotExistsMutex.Lock()
	defer fake.createConfigIfNotExistsMutex.Unlock()
	fake.CreateConfigIfNotExistsStub = nil
	fake.createConfigIfNotExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) CreateConfigIfNotExistsReturnsOnCall(i int, result1 error) {
	fake.createConfigIfNotExistsMutex.Lock()
	defer fake.createConfigIfNotExistsMutex.Unlock()
	fake.CreateConfigIfNotExistsStub = nil
	if fake.createConfigIfNotExistsReturnsOnCall == nil {
		fake.createConfigIfNotExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createConfigIfNotExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) DeleteConfigIfExists() error {
	fake.deleteConfigIfExistsMutex.Lock()
	ret, specificReturn := fake.deleteConfigIfExistsReturnsOnCall[len(fake.deleteConfigIfExistsArgsForCall)]
	fake.deleteConfigIfExistsArgsForCall = append(fake.deleteConfigIfExistsArgsForCall, struct {
	}{})
	stub := fake.DeleteConfigIfExistsStub
	fakeReturns := fake.deleteConfigIfExistsReturns
	fake.recordInvocation("DeleteConfigIfExists", []interface{}{})
	fake.deleteConfigIfExistsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) DeleteConfigIfExistsCallCount() int {
	fake.deleteConfigIfExistsMutex.RLock()
	defer fake.deleteConfigIfExistsMutex.RUnlock()
	return len(fake.deleteConfigIfExistsArgsForCall)
}

func (fake *FakeUpdater) DeleteConfigIfExistsCalls(stub func() error) {
	fake.deleteConfigIfExistsMutex.Lock()
	defer fake.deleteConfigIfExistsMutex.Unlock()
	fake.DeleteConfigIfExistsStub = stub
}

func (fake *FakeUpdater) DeleteConfigIfExistsReturns(result1 error) {
	fake.deleteConfigIfExistsMutex.Lock()
	defer fake.deleteConfigIfExistsMutex.Unlock()
	fake.DeleteConfigIfExistsStub = nil
	fake.deleteConfigIfExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) DeleteConfigIfExistsReturnsOnCall(i int, result1 error) {
	fake.deleteConfigIfExistsMutex.Lock()
	defer fake.deleteConfigIfExistsMutex.Unlock()
	fake.DeleteConfigIfExistsStub = nil
	if fake.deleteConfigIfExistsReturnsOnCall == nil {
		fake.deleteConfigIfExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteConfigIfExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) DeleteOrgConfig(arg1 string) error {
	fake.deleteOrgConfigMutex.Lock()
	ret, specificReturn := fake.deleteOrgConfigReturnsOnCall[len(fake.deleteOrgConfigArgsForCall)]
	fake.deleteOrgConfigArgsForCall = append(fake.deleteOrgConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteOrgConfigStub
	fakeReturns := fake.deleteOrgConfigReturns
	fake.recordInvocation("DeleteOrgConfig", []interface{}{arg1})
	fake.deleteOrgConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) DeleteOrgConfigCallCount() int {
	fake.deleteOrgConfigMutex.RLock()
	defer fake.deleteOrgConfigMutex.RUnlock()
	return len(fake.deleteOrgConfigArgsForCall)
}

func (fake *FakeUpdater) DeleteOrgConfigCalls(stub func(string) error) {
	fake.deleteOrgConfigMutex.Lock()
	defer fake.deleteOrgConfigMutex.Unlock()
	fake.DeleteOrgConfigStub = stub
}

func (fake *FakeUpdater) DeleteOrgConfigArgsForCall(i int) string {
	fake.deleteOrgConfigMutex.RLock()
	defer fake.deleteOrgConfigMutex.RUnlock()
	argsForCall := fake.deleteOrgConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) DeleteOrgConfigReturns(result1 error) {
	fake.deleteOrgConfigMutex.Lock()
	defer fake.deleteOrgConfigMutex.Unlock()
	fake.DeleteOrgConfigStub = nil
	fake.deleteOrgConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) DeleteOrgConfigReturnsOnCall(i int, result1 error) {
	fake.deleteOrgConfigMutex.Lock()
	defer fake.deleteOrgConfigMutex.Unlock()
	fake.DeleteOrgConfigStub = nil
	if fake.deleteOrgConfigReturnsOnCall == nil {
		fake.deleteOrgConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteOrgConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) DeleteSpaceConfig(arg1 string, arg2 string) error {
	fake.deleteSpaceConfigMutex.Lock()
	ret, specificReturn := fake.deleteSpaceConfigReturnsOnCall[len(fake.deleteSpaceConfigArgsForCall)]
	fake.deleteSpaceConfigArgsForCall = append(fake.deleteSpaceConfigArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteSpaceConfigStub
	fakeReturns := fake.deleteSpaceConfigReturns
	fake.recordInvocation("DeleteSpaceConfig", []interface{}{arg1, arg2})
	fake.deleteSpaceConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) DeleteSpaceConfigCallCount() int {
	fake.deleteSpaceConfigMutex.RLock()
	defer fake.deleteSpaceConfigMutex.RUnlock()
	return len(fake.deleteSpaceConfigArgsForCall)
}

func (fake *FakeUpdater) DeleteSpaceConfigCalls(stub func(string, string) error) {
	fake.deleteSpaceConfigMutex.Lock()
	defer fake.deleteSpaceConfigMutex.Unlock()
	fake.DeleteSpaceConfigStub = stub
}

func (fake *FakeUpdater) DeleteSpaceConfigArgsForCall(i int) (string, string) {
	fake.deleteSpaceConfigMutex.RLock()
	defer fake.deleteSpaceConfigMutex.RUnlock()
	argsForCall := fake.deleteSpaceConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUpdater) DeleteSpaceConfigReturns(result1 error) {
	fake.deleteSpaceConfigMutex.Lock()
	defer fake.deleteSpaceConfigMutex.Unlock()
	fake.DeleteSpaceConfigStub = nil
	fake.deleteSpaceConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) DeleteSpaceConfigReturnsOnCall(i int, result1 error) {
	fake.deleteSpaceConfigMutex.Lock()
	defer fake.deleteSpaceConfigMutex.Unlock()
	fake.DeleteSpaceConfigStub = nil
	if fake.deleteSpaceConfigReturnsOnCall == nil {
		fake.deleteSpaceConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSpaceConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) RenameOrgConfig(arg1 *config.OrgConfig) error {
	fake.renameOrgConfigMutex.Lock()
	ret, specificReturn := fake.renameOrgConfigReturnsOnCall[len(fake.renameOrgConfigArgsForCall)]
	fake.renameOrgConfigArgsForCall = append(fake.renameOrgConfigArgsForCall, struct {
		arg1 *config.OrgConfig
	}{arg1})
	stub := fake.RenameOrgConfigStub
	fakeReturns := fake.renameOrgConfigReturns
	fake.recordInvocation("RenameOrgConfig", []interface{}{arg1})
	fake.renameOrgConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) RenameOrgConfigCallCount() int {
	fake.renameOrgConfigMutex.RLock()
	defer fake.renameOrgConfigMutex.RUnlock()
	return len(fake.renameOrgConfigArgsForCall)
}

func (fake *FakeUpdater) RenameOrgConfigCalls(stub func(*config.OrgConfig) error) {
	fake.renameOrgConfigMutex.Lock()
	defer fake.renameOrgConfigMutex.Unlock()
	fake.RenameOrgConfigStub = stub
}

func (fake *FakeUpdater) RenameOrgConfigArgsForCall(i int) *config.OrgConfig {
	fake.renameOrgConfigMutex.RLock()
	defer fake.renameOrgConfigMutex.RUnlock()
	argsForCall := fake.renameOrgConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) RenameOrgConfigReturns(result1 error) {
	fake.renameOrgConfigMutex.Lock()
	defer fake.renameOrgConfigMutex.Unlock()
	fake.RenameOrgConfigStub = nil
	fake.renameOrgConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) RenameOrgConfigReturnsOnCall(i int, result1 error) {
	fake.renameOrgConfigMutex.Lock()
	defer fake.renameOrgConfigMutex.Unlock()
	fake.RenameOrgConfigStub = nil
	if fake.renameOrgConfigReturnsOnCall == nil {
		fake.renameOrgConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameOrgConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) RenameSpaceConfig(arg1 *config.SpaceConfig) error {
	fake.renameSpaceConfigMutex.Lock()
	ret, specificReturn := fake.renameSpaceConfigReturnsOnCall[len(fake.renameSpaceConfigArgsForCall)]
	fake.renameSpaceConfigArgsForCall = append(fake.renameSpaceConfigArgsForCall, struct {
		arg1 *config.SpaceConfig
	}{arg1})
	stub := fake.RenameSpaceConfigStub
	fakeReturns := fake.renameSpaceConfigReturns
	fake.recordInvocation("RenameSpaceConfig", []interface{}{arg1})
	fake.renameSpaceConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) RenameSpaceConfigCallCount() int {
	fake.renameSpaceConfigMutex.RLock()
	defer fake.renameSpaceConfigMutex.RUnlock()
	return len(fake.renameSpaceConfigArgsForCall)
}

func (fake *FakeUpdater) RenameSpaceConfigCalls(stub func(*config.SpaceConfig) error) {
	fake.renameSpaceConfigMutex.Lock()
	defer fake.renameSpaceConfigMutex.Unlock()
	fake.RenameSpaceConfigStub = stub
}

func (fake *FakeUpdater) RenameSpaceConfigArgsForCall(i int) *config.SpaceConfig {
	fake.renameSpaceConfigMutex.RLock()
	defer fake.renameSpaceConfigMutex.RUnlock()
	argsForCall := fake.renameSpaceConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) RenameSpaceConfigReturns(result1 error) {
	fake.renameSpaceConfigMutex.Lock()
	defer fake.renameSpaceConfigMutex.Unlock()
	fake.RenameSpaceConfigStub = nil
	fake.renameSpaceConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) RenameSpaceConfigReturnsOnCall(i int, result1 error) {
	fake.renameSpaceConfigMutex.Lock()
	defer fake.renameSpaceConfigMutex.Unlock()
	fake.RenameSpaceConfigStub = nil
	if fake.renameSpaceConfigReturnsOnCall == nil {
		fake.renameSpaceConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameSpaceConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveGlobalConfig(arg1 *config.GlobalConfig) error {
	fake.saveGlobalConfigMutex.Lock()
	ret, specificReturn := fake.saveGlobalConfigReturnsOnCall[len(fake.saveGlobalConfigArgsForCall)]
	fake.saveGlobalConfigArgsForCall = append(fake.saveGlobalConfigArgsForCall, struct {
		arg1 *config.GlobalConfig
	}{arg1})
	stub := fake.SaveGlobalConfigStub
	fakeReturns := fake.saveGlobalConfigReturns
	fake.recordInvocation("SaveGlobalConfig", []interface{}{arg1})
	fake.saveGlobalConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) SaveGlobalConfigCallCount() int {
	fake.saveGlobalConfigMutex.RLock()
	defer fake.saveGlobalConfigMutex.RUnlock()
	return len(fake.saveGlobalConfigArgsForCall)
}

func (fake *FakeUpdater) SaveGlobalConfigCalls(stub func(*config.GlobalConfig) error) {
	fake.saveGlobalConfigMutex.Lock()
	defer fake.saveGlobalConfigMutex.Unlock()
	fake.SaveGlobalConfigStub = stub
}

func (fake *FakeUpdater) SaveGlobalConfigArgsForCall(i int) *config.GlobalConfig {
	fake.saveGlobalConfigMutex.RLock()
	defer fake.saveGlobalConfigMutex.RUnlock()
	argsForCall := fake.saveGlobalConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) SaveGlobalConfigReturns(result1 error) {
	fake.saveGlobalConfigMutex.Lock()
	defer fake.saveGlobalConfigMutex.Unlock()
	fake.SaveGlobalConfigStub = nil
	fake.saveGlobalConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveGlobalConfigReturnsOnCall(i int, result1 error) {
	fake.saveGlobalConfigMutex.Lock()
	defer fake.saveGlobalConfigMutex.Unlock()
	fake.SaveGlobalConfigStub = nil
	if fake.saveGlobalConfigReturnsOnCall == nil {
		fake.saveGlobalConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveGlobalConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveOrgConfig(arg1 *config.OrgConfig) error {
	fake.saveOrgConfigMutex.Lock()
	ret, specificReturn := fake.saveOrgConfigReturnsOnCall[len(fake.saveOrgConfigArgsForCall)]
	fake.saveOrgConfigArgsForCall = append(fake.saveOrgConfigArgsForCall, struct {
		arg1 *config.OrgConfig
	}{arg1})
	stub := fake.SaveOrgConfigStub
	fakeReturns := fake.saveOrgConfigReturns
	fake.recordInvocation("SaveOrgConfig", []interface{}{arg1})
	fake.saveOrgConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) SaveOrgConfigCallCount() int {
	fake.saveOrgConfigMutex.RLock()
	defer fake.saveOrgConfigMutex.RUnlock()
	return len(fake.saveOrgConfigArgsForCall)
}

func (fake *FakeUpdater) SaveOrgConfigCalls(stub func(*config.OrgConfig) error) {
	fake.saveOrgConfigMutex.Lock()
	defer fake.saveOrgConfigMutex.Unlock()
	fake.SaveOrgConfigStub = stub
}

func (fake *FakeUpdater) SaveOrgConfigArgsForCall(i int) *config.OrgConfig {
	fake.saveOrgConfigMutex.RLock()
	defer fake.saveOrgConfigMutex.RUnlock()
	argsForCall := fake.saveOrgConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) SaveOrgConfigReturns(result1 error) {
	fake.saveOrgConfigMutex.Lock()
	defer fake.saveOrgConfigMutex.Unlock()
	fake.SaveOrgConfigStub = nil
	fake.saveOrgConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveOrgConfigReturnsOnCall(i int, result1 error) {
	fake.saveOrgConfigMutex.Lock()
	defer fake.saveOrgConfigMutex.Unlock()
	fake.SaveOrgConfigStub = nil
	if fake.saveOrgConfigReturnsOnCall == nil {
		fake.saveOrgConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveOrgConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveOrgQuota(arg1 *config.OrgQuota) error {
	fake.saveOrgQuotaMutex.Lock()
	ret, specificReturn := fake.saveOrgQuotaReturnsOnCall[len(fake.saveOrgQuotaArgsForCall)]
	fake.saveOrgQuotaArgsForCall = append(fake.saveOrgQuotaArgsForCall, struct {
		arg1 *config.OrgQuota
	}{arg1})
	stub := fake.SaveOrgQuotaStub
	fakeReturns := fake.saveOrgQuotaReturns
	fake.recordInvocation("SaveOrgQuota", []interface{}{arg1})
	fake.saveOrgQuotaMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) SaveOrgQuotaCallCount() int {
	fake.saveOrgQuotaMutex.RLock()
	defer fake.saveOrgQuotaMutex.RUnlock()
	return len(fake.saveOrgQuotaArgsForCall)
}

func (fake *FakeUpdater) SaveOrgQuotaCalls(stub func(*config.OrgQuota) error) {
	fake.saveOrgQuotaMutex.Lock()
	defer fake.saveOrgQuotaMutex.Unlock()
	fake.SaveOrgQuotaStub = stub
}

func (fake *FakeUpdater) SaveOrgQuotaArgsForCall(i int) *config.OrgQuota {
	fake.saveOrgQuotaMutex.RLock()
	defer fake.saveOrgQuotaMutex.RUnlock()
	argsForCall := fake.saveOrgQuotaArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) SaveOrgQuotaReturns(result1 error) {
	fake.saveOrgQuotaMutex.Lock()
	defer fake.saveOrgQuotaMutex.Unlock()
	fake.SaveOrgQuotaStub = nil
	fake.saveOrgQuotaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveOrgQuotaReturnsOnCall(i int, result1 error) {
	fake.saveOrgQuotaMutex.Lock()
	defer fake.saveOrgQuotaMutex.Unlock()
	fake.SaveOrgQuotaStub = nil
	if fake.saveOrgQuotaReturnsOnCall == nil {
		fake.saveOrgQuotaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveOrgQuotaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveOrgSpaces(arg1 *config.Spaces) error {
	fake.saveOrgSpacesMutex.Lock()
	ret, specificReturn := fake.saveOrgSpacesReturnsOnCall[len(fake.saveOrgSpacesArgsForCall)]
	fake.saveOrgSpacesArgsForCall = append(fake.saveOrgSpacesArgsForCall, struct {
		arg1 *config.Spaces
	}{arg1})
	stub := fake.SaveOrgSpacesStub
	fakeReturns := fake.saveOrgSpacesReturns
	fake.recordInvocation("SaveOrgSpaces", []interface{}{arg1})
	fake.saveOrgSpacesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) SaveOrgSpacesCallCount() int {
	fake.saveOrgSpacesMutex.RLock()
	defer fake.saveOrgSpacesMutex.RUnlock()
	return len(fake.saveOrgSpacesArgsForCall)
}

func (fake *FakeUpdater) SaveOrgSpacesCalls(stub func(*config.Spaces) error) {
	fake.saveOrgSpacesMutex.Lock()
	defer fake.saveOrgSpacesMutex.Unlock()
	fake.SaveOrgSpacesStub = stub
}

func (fake *FakeUpdater) SaveOrgSpacesArgsForCall(i int) *config.Spaces {
	fake.saveOrgSpacesMutex.RLock()
	defer fake.saveOrgSpacesMutex.RUnlock()
	argsForCall := fake.saveOrgSpacesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) SaveOrgSpacesReturns(result1 error) {
	fake.saveOrgSpacesMutex.Lock()
	defer fake.saveOrgSpacesMutex.Unlock()
	fake.SaveOrgSpacesStub = nil
	fake.saveOrgSpacesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveOrgSpacesReturnsOnCall(i int, result1 error) {
	fake.saveOrgSpacesMutex.Lock()
	defer fake.saveOrgSpacesMutex.Unlock()
	fake.SaveOrgSpacesStub = nil
	if fake.saveOrgSpacesReturnsOnCall == nil {
		fake.saveOrgSpacesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveOrgSpacesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveOrgs(arg1 *config.Orgs) error {
	fake.saveOrgsMutex.Lock()
	ret, specificReturn := fake.saveOrgsReturnsOnCall[len(fake.saveOrgsArgsForCall)]
	fake.saveOrgsArgsForCall = append(fake.saveOrgsArgsForCall, struct {
		arg1 *config.Orgs
	}{arg1})
	stub := fake.SaveOrgsStub
	fakeReturns := fake.saveOrgsReturns
	fake.recordInvocation("SaveOrgs", []interface{}{arg1})
	fake.saveOrgsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) SaveOrgsCallCount() int {
	fake.saveOrgsMutex.RLock()
	defer fake.saveOrgsMutex.RUnlock()
	return len(fake.saveOrgsArgsForCall)
}

func (fake *FakeUpdater) SaveOrgsCalls(stub func(*config.Orgs) error) {
	fake.saveOrgsMutex.Lock()
	defer fake.saveOrgsMutex.Unlock()
	fake.SaveOrgsStub = stub
}

func (fake *FakeUpdater) SaveOrgsArgsForCall(i int) *config.Orgs {
	fake.saveOrgsMutex.RLock()
	defer fake.saveOrgsMutex.RUnlock()
	argsForCall := fake.saveOrgsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) SaveOrgsReturns(result1 error) {
	fake.saveOrgsMutex.Lock()
	defer fake.saveOrgsMutex.Unlock()
	fake.SaveOrgsStub = nil
	fake.saveOrgsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveOrgsReturnsOnCall(i int, result1 error) {
	fake.saveOrgsMutex.Lock()
	defer fake.saveOrgsMutex.Unlock()
	fake.SaveOrgsStub = nil
	if fake.saveOrgsReturnsOnCall == nil {
		fake.saveOrgsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveOrgsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveSpaceConfig(arg1 *config.SpaceConfig) error {
	fake.saveSpaceConfigMutex.Lock()
	ret, specificReturn := fake.saveSpaceConfigReturnsOnCall[len(fake.saveSpaceConfigArgsForCall)]
	fake.saveSpaceConfigArgsForCall = append(fake.saveSpaceConfigArgsForCall, struct {
		arg1 *config.SpaceConfig
	}{arg1})
	stub := fake.SaveSpaceConfigStub
	fakeReturns := fake.saveSpaceConfigReturns
	fake.recordInvocation("SaveSpaceConfig", []interface{}{arg1})
	fake.saveSpaceConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) SaveSpaceConfigCallCount() int {
	fake.saveSpaceConfigMutex.RLock()
	defer fake.saveSpaceConfigMutex.RUnlock()
	return len(fake.saveSpaceConfigArgsForCall)
}

func (fake *FakeUpdater) SaveSpaceConfigCalls(stub func(*config.SpaceConfig) error) {
	fake.saveSpaceConfigMutex.Lock()
	defer fake.saveSpaceConfigMutex.Unlock()
	fake.SaveSpaceConfigStub = stub
}

func (fake *FakeUpdater) SaveSpaceConfigArgsForCall(i int) *config.SpaceConfig {
	fake.saveSpaceConfigMutex.RLock()
	defer fake.saveSpaceConfigMutex.RUnlock()
	argsForCall := fake.saveSpaceConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) SaveSpaceConfigReturns(result1 error) {
	fake.saveSpaceConfigMutex.Lock()
	defer fake.saveSpaceConfigMutex.Unlock()
	fake.SaveSpaceConfigStub = nil
	fake.saveSpaceConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveSpaceConfigReturnsOnCall(i int, result1 error) {
	fake.saveSpaceConfigMutex.Lock()
	defer fake.saveSpaceConfigMutex.Unlock()
	fake.SaveSpaceConfigStub = nil
	if fake.saveSpaceConfigReturnsOnCall == nil {
		fake.saveSpaceConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveSpaceConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveSpaceQuota(arg1 *config.SpaceQuota) error {
	fake.saveSpaceQuotaMutex.Lock()
	ret, specificReturn := fake.saveSpaceQuotaReturnsOnCall[len(fake.saveSpaceQuotaArgsForCall)]
	fake.saveSpaceQuotaArgsForCall = append(fake.saveSpaceQuotaArgsForCall, struct {
		arg1 *config.SpaceQuota
	}{arg1})
	stub := fake.SaveSpaceQuotaStub
	fakeReturns := fake.saveSpaceQuotaReturns
	fake.recordInvocation("SaveSpaceQuota", []interface{}{arg1})
	fake.saveSpaceQuotaMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeUpdater) SaveSpaceQuotaCallCount() int {
	fake.saveSpaceQuotaMutex.RLock()
	defer fake.saveSpaceQuotaMutex.RUnlock()
	return len(fake.saveSpaceQuotaArgsForCall)
}

func (fake *FakeUpdater) SaveSpaceQuotaCalls(stub func(*config.SpaceQuota) error) {
	fake.saveSpaceQuotaMutex.Lock()
	defer fake.saveSpaceQuotaMutex.Unlock()
	fake.SaveSpaceQuotaStub = stub
}

func (fake *FakeUpdater) SaveSpaceQuotaArgsForCall(i int) *config.SpaceQuota {
	fake.saveSpaceQuotaMutex.RLock()
	defer fake.saveSpaceQuotaMutex.RUnlock()
	argsForCall := fake.saveSpaceQuotaArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUpdater) SaveSpaceQuotaReturns(result1 error) {
	fake.saveSpaceQuotaMutex.Lock()
	defer fake.saveSpaceQuotaMutex.Unlock()
	fake.SaveSpaceQuotaStub = nil
	fake.saveSpaceQuotaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) SaveSpaceQuotaReturnsOnCall(i int, result1 error) {
	fake.saveSpaceQuotaMutex.Lock()
	defer fake.saveSpaceQuotaMutex.Unlock()
	fake.SaveSpaceQuotaStub = nil
	if fake.saveSpaceQuotaReturnsOnCall == nil {
		fake.saveSpaceQuotaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveSpaceQuotaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUpdater) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addDefaultSecurityGroupMutex.RLock()
	defer fake.addDefaultSecurityGroupMutex.RUnlock()
	fake.addOrgQuotaMutex.RLock()
	defer fake.addOrgQuotaMutex.RUnlock()
	fake.addOrgToConfigMutex.RLock()
	defer fake.addOrgToConfigMutex.RUnlock()
	fake.addSecurityGroupMutex.RLock()
	defer fake.addSecurityGroupMutex.RUnlock()
	fake.addSecurityGroupToSpaceMutex.RLock()
	defer fake.addSecurityGroupToSpaceMutex.RUnlock()
	fake.addSpaceQuotaMutex.RLock()
	defer fake.addSpaceQuotaMutex.RUnlock()
	fake.addSpaceToConfigMutex.RLock()
	defer fake.addSpaceToConfigMutex.RUnlock()
	fake.associateOrgAuditorMutex.RLock()
	defer fake.associateOrgAuditorMutex.RUnlock()
	fake.associateSpaceAuditorMutex.RLock()
	defer fake.associateSpaceAuditorMutex.RUnlock()
	fake.associateSpaceDeveloperMutex.RLock()
	defer fake.associateSpaceDeveloperMutex.RUnlock()
	fake.createConfigIfNotExistsMutex.RLock()
	defer fake.createConfigIfNotExistsMutex.RUnlock()
	fake.deleteConfigIfExistsMutex.RLock()
	defer fake.deleteConfigIfExistsMutex.RUnlock()
	fake.deleteOrgConfigMutex.RLock()
	defer fake.deleteOrgConfigMutex.RUnlock()
	fake.deleteSpaceConfigMutex.RLock()
	defer fake.deleteSpaceConfigMutex.RUnlock()
	fake.renameOrgConfigMutex.RLock()
	defer fake.renameOrgConfigMutex.RUnlock()
	fake.renameSpaceConfigMutex.RLock()
	defer fake.renameSpaceConfigMutex.RUnlock()
	fake.saveGlobalConfigMutex.RLock()
	defer fake.saveGlobalConfigMutex.RUnlock()
	fake.saveOrgConfigMutex.RLock()
	defer fake.saveOrgConfigMutex.RUnlock()
	fake.saveOrgQuotaMutex.RLock()
	defer fake.saveOrgQuotaMutex.RUnlock()
	fake.saveOrgSpacesMutex.RLock()
	defer fake.saveOrgSpacesMutex.RUnlock()
	fake.saveOrgsMutex.RLock()
	defer fake.saveOrgsMutex.RUnlock()
	fake.saveSpaceConfigMutex.RLock()
	defer fake.saveSpaceConfigMutex.RUnlock()
	fake.saveSpaceQuotaMutex.RLock()
	defer fake.saveSpaceQuotaMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUpdater) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ config.Updater = new(FakeUpdater)
